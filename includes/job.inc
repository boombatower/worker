<?php
/**
 * @file
 * Provide convenience functions and environment setup for jobs.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * Root directory for job.
 */
define('JOB_ROOT', DRUPAL_ROOT . '/' . file_directory_path() . '/job');

/**
 * Perform the given job.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   The result of the job or FALSE.
 */
function worker_perform(array $properties) {
  $result = array(
    'status' => 'failure',
    'result' => NULL,
  );

  // Ensure that the job plugin can be loaded.
  if ($plugin = worker_plugins_get('worker', $properties['plugin'])) {
    worker_log('Starting job ' . $properties['item']->data['nid'] . '.' . $properties['item']->data['vid'] . '.' . $properties['item']->data['delta'] . '.');
    worker_verbose($properties['verbose']);

    // Perform preparation and then job.
    if (worker_prepare($properties)) {
      // Ensure the working directory is set to the DRUPAL_ROOT and invoke the
      // plugin with the job properties.
      chdir(DRUPAL_ROOT);
      if ($result['result'] = $plugin['perform']($properties)) {
        $result['status'] = 'success';
      }
    }

    chdir(DRUPAL_ROOT);
    worker_log('Job exiting.');
  }

  // Load log file contents as an array so the second to last line can be
  // accessed if necessary.
  $log = file(file_directory_path() . '/job.log');
  $result['log'] = implode("\n", $log);

  // If the job was a failure then use the second to last line from the log as
  // the error message after trimming off the time offset.
  if ($result['status'] == 'failure') {
    array_pop($log);
    $result['result'] = substr(array_pop($log), 12);
  }
  return $result;
}

/**
 * Perform preparation needed before job runs.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_prepare(array $properties) {
  // Ensure the job root directory is available.
  if (!worker_directory_prepare()) {
    worker_log('Failed to prepare job root directory.');
    return FALSE;
  }

  if (!worker_setup($properties)) {
    worker_log('Failed to complete execution of setup commands.');
    return FALSE;
  }

  if (!worker_ssh($properties)) {
    return FALSE;
  }

  if (!worker_vcs($properties)) {
    return FALSE;
  }

  if (!worker_patch($properties)) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Prepare the job root directory.
 *
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_directory_prepare($directory = JOB_ROOT) {
  // If directory exists then clear it out.
  if (file_exists($directory)) {
    worker_delete_recursive($directory);
  }

  // Create directory.
  return file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
}

/**
 * Allow commands to be run during setup phase.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_setup(array $properties) {
  foreach ($properties['setup'] as $command) {
    worker_log('Setup [' . $command . '].');
    if (!worker_execute(escapeshellcmd($command))) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Prepare ssh keys.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_ssh(array $properties) {
  // Determine the web user home directory.
  if (($home = array_pop(worker_execute_output('eval echo ~$(whoami)'))) && is_dir($home)) {
    // Clean out .ssh directory and recreate it.
    worker_directory_prepare($home . '/.ssh');

    // Initialize ssh config file.
    file_put_contents($home . '/.ssh/config', "# Auto generated by conduit. Do not modify this file manually.\n\n");

    // Cycle through ssh key information and process.
    $delta = 0;
    foreach ($properties['ssh'] as $info) {
      worker_log('Adding ssh key for host ' . $info['host'] . '.');
      // Write the ssh key to a file and set the appropriate permissions.
      $file = $home . '/.ssh/id_rsa.' . ++$delta;
      file_put_contents($file, $info['key']);
      chmod($file, 0600);

      // Add an entry in the ssh config file for the key.
      $config = "Host {$info['host']}\n" .
        "\tIdentityFile $file\n" .
        "\tUser {$info['user']}\n" .
        "\tPort {$info['port']}\n\n";
      file_put_contents($home . '/.ssh/config', $config, FILE_APPEND);

      // Add the host to the known_hosts file.
      $line = array_shift(worker_execute_output('ssh -o StrictHostKeyChecking=no ' . escapeshellarg($info['host']) . ' exit'));
      if (preg_match('/Warning: Permanently added .*? to the list of known hosts./', $line)) {
        // Coninue with next ssh key.
        continue;
      }
      worker_log('Failed to setup ssh key for ' . $info['host'] . '.');
      return FALSE;
    }
    return TRUE;
  }
  worker_log('Failed to determine the webuser home directory path.');
  return FALSE;
}

/**
 * Process version control repositories.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_vcs(array $properties) {
  // Cycle through all repositories until complete or an error is encountered.
  foreach ($properties['vcs'] as $path => $url) {
    // Load plugin appropriate for handling the scheme.
    if ($vcs = worker_plugins_get_vcs($url)) {
      // Ensure the path specified exists.
      worker_directory_prepare(JOB_ROOT . '/' . $path);
      worker_chdir($path);

      // Checkout from the repository.
      worker_log('Checkout ' . $url . ' into /' . $path . '.');
      if (!$vcs['checkout']($url)) {
        return FALSE;
      }

      // Return to the Drupal root after processing a repository successfully
      // to ensure that the next plugin is loaded properly.
      chdir(DRUPAL_ROOT);
    }
    else {
      worker_log('Unsupported scheme in [' . $url . '].');
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Apply a list of patches.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_patch(array $properties) {
  // Prepare patch storage directory.
  worker_directory_prepare($directory = DRUPAL_ROOT . '/' . file_directory_path() . '/patch');

  // Cycle through all the patches, download them and apply them.
  $delta = 0;
  foreach ($properties['patch'] as $url => $path) {
    if (!empty($properties['vcs'][$path]) && ($vcs = worker_plugins_get_vcs($properties['vcs'][$path]))) {
      // Use the path specified as the root the patch is to be applied to. Use
      // a delta to ensure patch file names do not conflict.
      worker_chdir($path);
      $local = worker_fetch($url, $directory, $delta++);
      $name = basename($url);

      // If requested check for non-unix newline characters.
      if ($properties['newline'] == 'unix' && strpos(file_get_contents($local), "\r") !== FALSE) {
        worker_log('Non-unix new line character(s) found in ' . $name . '.');
        return FALSE;
      }

      // Ensure that path the patch is to be applied to is readable.
      worker_log('Apply ' . $name . ' to /' . $path . '.');
      if (!$vcs['apply']($local)) {
        worker_log('Failed to apply patch ' . $name . '.');
        return FALSE;
      }
      worker_log_list('Modified files:', $vcs['modified files']($local));
    }
    else {
      worker_log('No repository corresponds to path /' . $path . ' for ' . basename($url) . '.');
      return FALSE;
    }
  }
  chdir(DRUPAL_ROOT);
  return TRUE;
}

/**
 * Fetch a file and place in directory.
 *
 * @param $url
 *   URL of file to fetch.
 * @param $directory
 *   Directory to place file in.
 * @param $suffix
 *   Suffix to append to the local name of the file.
 * @return
 *   Local path to file, or FALSE if retrieval/storage failed.
 */
function worker_fetch($url, $directory, $suffix = '') {
  // Request the file at the given URL.
  $response = drupal_http_request($url); // @TODO Possibly allow for none http protocols.
  if ($response->code != 200) {
    worker_log('Unable to fetch ' . $url . ' due to [' . $response->error . '].');
    return FALSE;
  }

  // Save the file contents in the given directory.
  $local = $directory . '/' . basename($url) . $suffix;
  if (file_put_contents($local, $response->data) === FALSE) {
    worker_log('Failed to save file data to ' . $local . '.');
    return FALSE;
  }
  return $local;
}

/**
 * Apply a patch in the working directory.
 *
 * @param $patch
 *   Path to patch file.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_patch_apply($patch) {
  return worker_execute('patch -p0 -i ' . escapeshellarg($patch));
}

/**
 * Get a list of all files modified by a patch.
 *
 * @param
 *   Path to patch file, which must be in the unified format.
 * @return
 *   List of files modified by the patch.
 */
function worker_patch_modified_files($patch) {
  // Load the patch file and use regular expression to find all files modified
  // by the patch.
  $contents = file_get_contents($patch);
  preg_match_all('/^[\+-]{3} (.*?)\s/m', $contents, $matches, PREG_SET_ORDER);

  $files = array();
  foreach ($matches as $match) {
    // Ignore reference to /dev/null which will occur when a file is being
    // added or removed.
    if ($match[1] != '/dev/null') {
      $files[$match[1]] = $match[1];
    }
  }
  return array_values($files);
}

/**
 * Evaluate scope properties to generate a list of files.
 *
 * @param $properties
 *   Associative array of properties containing keys: path, mask, and nomask.
 * @return
 *   List of files relative to the JOB_ROOT.
 */
function worker_file_list(array $properties) {
  // Cycle through all paths, determine if path points to a file or directory
  // and process accordingly.
  $files = array();
  foreach ($properties['path'] as $path) {
    $name = basename($path);
    $full_path = JOB_ROOT . '/' . $path;

    // Ensure path exists.
    if (!file_exists($full_path)) {
      worker_log('Invalid path /' . $path . '.');
      return FALSE;
    }

    // If path points to a directory then scan all the files within using the
    // mask and no mask properties.
    if (is_dir($full_path)) {
      $scan = file_scan_directory($full_path, $properties['mask'], array('nomask' => $properties['nomask']));

      // Cycle through resulting files and create an associative array of
      // relative paths.
      foreach ($scan as $uri => $info) {
        $path = str_replace(JOB_ROOT . '/', '', $uri);
        $files[$path] = $path;
      }
    }
    else {
      // Always add files reguardless of mask and nomask.
      $files[$path] = $path;
    }
  }

  // Sort files and return a list of relative paths.
  ksort($files);
  return array_keys($files);
}

/**
 * Check for syntax errors.
 *
 * @param $properties
 *   Associative array of properties defining the job.
 * @param $callback
 *   (Optional) Function to call in order to check the syntax of a file. The
 *   only parameter passed the function will be the file path relative to the
 *   current working directory. The function is expected to return TRUE if the
 *   file passed the syntax check, an array containing a message and line
 *   number of the error (or FALSE), or FALSE if the syntax check failed to run
 *   properly. The callback is defautly set to check PHP syntax.
 * @return
 *   Associative array of syntax errors keyed by path and containing 'messaage'
 *   and 'context' (an array of lines), or FALSE if an error occured.
 */
function worker_syntax(array $properties, $callback = 'worker_syntax_php') {
  worker_log('Assemble list of files to syntax check.');
  if (!($files = worker_file_list($properties))) {
    return FALSE;
  }
  worker_log('Syntax check ' . count($files) . ' file(s).');

  worker_chdir();
  $errors = array();
  foreach ($files as $file) {
    worker_log('> Check ' . $file . '.');
    if ($error = $callback($file)) {
      // Continue if the file passed the syntax check.
      if ($error === TRUE) {
        continue;
      }

      $errors[$file] = array(
        'message' => $error['message'],
        'context' => array(),
      );

      // If the line referenced by the message was determined then pull seven
      // relevant lines from the file as context.
      if ($error['line']) {
        $lines = file($file);
        $errors[$file]['context'] = array_slice($lines, $error['line'] - 4, 7, TRUE);
      }
    }
    else {
      worker_log('PHP syntax check did not respond properly.');
      return FALSE;
    }
  }
  chdir(DRUPAL_ROOT);

  if (!empty($errors)) {
    worker_log_list('PHP syntax errors found in the following file(s):', array_keys($errors));
  }
  return $errors;
}

/**
 * Check the syntax of a PHP file.
 *
 * @param $file
 *   Relative path to file.
 * @return
 *   See worker_syntax() for details on the return value
 * @see worker_syntax()
 */
function worker_syntax_php($file) {
  if ($output = worker_execute_output('php -l -f ' . escapeshellarg($file))) {
    $output = $output[0];
    if (strpos($output, 'No syntax errors detected') === FALSE) {
      $error = array(
        'message' => $output,
        'line' => FALSE,
      );

      // If the messages follows the standard and the line number can be
      // determined with a the regular expression then return it.
      if (preg_match('/line (?P<line>\d+)$/m', $output, $match)) {
        $error['line'] = $match['line'];
      }
      return $error;
    }
    return TRUE;
  }
  return FALSE;
}

/**
 * Prepare a database and return the connection object.
 *
 * For each $prefix/$driver pair there should exist two database connections in
 * the $databases array found in settings.php. The keys should follow the
 * format: [PREFIX]_[DRIVER], [PREFIX]_[DRIVER]_stub. The stub connection
 * should point to an existing database of the proper type that is empty while
 * the primary should not point to an existing database, but the user should
 * have permission to create and drop the database it points to.
 *
 * @param $prefix
 *   The prefix used in the $databases array.
 * @param $driver
 *   The database driver which the connection should use.
 * @return
 *   A database connection object on success, otherwise FALSE.
 */
function worker_database($prefix, $driver) {
  static $prepared = FALSE;

  // Generate database key strings.
  $name = $prefix . '_' . $driver;
  $stub = $name . '_stub';

  // If the database connection has already been prepared then simply return it.
  if ($prepared) {
    return Database::getConnection('default', $name);
  }

  // Attempt to prepare the database connection using the stub connection.
  global $databases;
  if ($connection = Database::getConnection('default', $stub)) {
    // Attempt to load the worker database plugin for the specified driver.
    if ($plugin = worker_plugins_get('database', $driver)) {
      // Ensure the database connection information is available for the primary database.
      if (!empty($databases[$name]['default']['database'])) {
        // Attempt to drop/create the primary database using the stub
        // connection with the appropriate driver.
        $database = $databases[$name]['default']['database'];
        if ($plugin['drop']($connection, $database) && $plugin['create']($connection, $database)) {
          $prepared = TRUE;
          return worker_database($prefix, $driver);
        }
        worker_log('Failed to prepare (drop/create) the primary database.');
      }
      else {
        worker_log('Failed to find the primary database information.');
      }
    }
    else {
      worker_log('Failed to load database driver for ' . $driver . '.');
    }
  }
  else {
    worker_log('Failed to load stub database connection.');
  }
  return FALSE;
}

/**
 * Get the database information for the primary database.
 *
 * @param $prefix
 *   The prefix used in the $databases array.
 * @param $driver
 *   The database driver which the connection should use.
 * @return
 *   Database information from $databases array in settings.php.
 */
function worker_database_info($prefix, $driver) {
  global $databases;
  return $databases[$prefix . '_' . $driver]['default'];
}

/**
 * Wrapper for PHP exec() function.
 *
 * All commands executed on the worker should be run through this command or
 * worker_execute_output(). If the exit status is non-zero the occurance will
 * be logged.
 *
 * @param $command
 *   Command to execute.
 * @param $return_output
 *   (Optional) Return the output of the command instead of TRUE or FALSE.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 */
function worker_execute($command, $return_output = FALSE, $capture_stderr = TRUE) {
  // Redirect the stderr to stdout so it is also captured.
  if ($capture_stderr) {
    $command .= ' 2>&1';
  }

  // Execute the command and capture the output and status.
  exec($command, $output, $status);

  // If that exit status is non-zero then log the occurance.
  if ($status != 0 || worker_verbose()) {
    worker_log("The following command generated a non-zero exit status of $status:\n" .
      "$command\n" .
      ($output ? trim(implode("\n", $output)) : '<<no output>>'));
  }
  return $return_output ? $output : $status == 0;
}

/**
 * Wrapper for PHP exec() function that return the output.
 *
 * @param $command
 *   Command to execute.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 * @see worker_execute()
 */
function worker_execute_output($command, $capture_stderr = TRUE) {
  return worker_execute($command, TRUE, $capture_stderr);
}

/**
 * Wrapper for PHP chdir() function, that starts from JOB_ROOT.
 *
 * @param $directory
 *   Directory within the job root to switch to.
 */
function worker_chdir($directory = '') {
  chdir(JOB_ROOT . '/' . $directory);
}

/**
 * Delete a path recursively.
 *
 * Replacement for file_unmanaged_delete_recursive() since the latter will not
 * always delete symbolic links which may be contained in a directory.
 *
 * @param $path
 *   Path to directory or file that will be recursively deleted.
 */
function worker_delete_recursive($path) {
  if (is_dir($path)) {
    // Cycle through all entries in directory and recursively remove them.
    $files = scandir($path);
    foreach ($files as $file) {
      if ($file != '.' && $file != '..') {
        worker_delete_recursive($path . '/' . $file);
      }
    }

    // Remove the directory itself.
    rmdir($path);
  }
  else {
    // Do not check if the file exists since the check may fail if the file is
    // a symbolic link and the file should always exist.
    unlink($path);
  }
}

/**
 * Add the string to the log.
 *
 * @param $string
 *   Message string to log.
 */
function worker_log($string) {
  static $start, $log_file;

  // First time function is called then initialze the $start to the current
  // float version of microtime(), generate the $log_file uri and create a
  // blank log file.
  if (!$start) {
    $start = microtime(TRUE);
    $log_file = DRUPAL_ROOT . '/' . file_directory_path() . '/job.log';
    file_put_contents($log_file, '');
  }

  // Write the log message with length of time since logging was started and
  // the message followed by a newline character.
  file_put_contents($log_file, sprintf("[%10s] %s\n", number_format(microtime(TRUE) - $start, 6), $string), FILE_APPEND);
}

/**
 * Wrapper for worker_log() that formats a list of values.
 *
 * @param $string
 *   Message string to log.
 * @param $list
 *   List of values to be printed in log.
 */
function worker_log_list($string, $list) {
  worker_log($string . "\n > " . implode("\n > ", $list));
}

/**
 * Check if worker is in verbose mode.
 *
 * @param
 *   (Optional) Verbose mode to use, this should only be set by worker init.
 * @return
 *   TRUE if in verbose mode, otherwise FALSE.
 */
function worker_verbose($verbose = NULL) {
  static $_verbose;
  if ($verbose) {
    $_verbose = (bool) $verbose;
  }
  return $_verbose;
}
