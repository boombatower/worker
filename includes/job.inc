<?php
/**
 * @file
 * Provide convenience functions and environment setup for jobs.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * Root directory for job.
 */
define('JOB_ROOT', DRUPAL_ROOT . '/' . file_directory_path() . '/job');

/**
 * Perform the given job.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   The result of the job or FALSE.
 */
function worker_perform(array $properties) {
  $result = FALSE;

  // Ensure that the job plugin can be loaded.
  if ($plugin = worker_plugins_get('worker', $properties['plugin'])) {
    worker_log('Starting job ' . $properties['item']->data['nid'] . '.' . $properties['item']->data['vid'] . '.' . $properties['item']->data['delta'] . '.');

    // Perform preparation and then job.
    if (worker_prepare($properties)) {
      // Ensure the working directory is set to the DRUPAL_ROOT and invoke the
      // plugin with the job properties.
      chdir(DRUPAL_ROOT);
      $result = $plugin['perform']($properties);
    }

    chdir(DRUPAL_ROOT);
    worker_log('Job exiting.');
  }
  return $result;
}

/**
 * Perform preparation needed before job runs.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_prepare(array $properties) {
  // Ensure the job root directory is available.
  if (!worker_directory_prepare()) {
    worker_log('Failed to prepare job root directory.');
    return FALSE;
  }

  if (!empty($properties['setup'])) {
    worker_setup($properties);
  }

  // If ssh keys specified then process them.
  if (!empty($properties['ssh'])) {
    worker_ssh($properties);
  }

  // If version control repositories specified then process them.
  if (!empty($properties['vcs'])) {
    if (!worker_vcs($properties)) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Prepare the job root directory.
 *
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_directory_prepare($directory = JOB_ROOT) {
  // If directory exists then clear it out.
  if (file_exists($directory)) {
    worker_delete_recursive($directory);
  }

  // Create directory.
  return file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
}

/**
 * Allow commands to be run during setup phase.
 *
 * @param $properties
 *   Associative array of job properties.
 */
function worker_setup(array $properties) {
  foreach ($properties['setup'] as $command) {
    worker_log('Setup [' . $command . '].');
    worker_execute(escapeshellcmd($command));
  }
}

/**
 * Prepare ssh keys.
 *
 * @param $properties
 *   Associative array of job properties.
 */
function worker_ssh(array $properties) {
  // Determine the web user home directory.
  if ($home = array_pop(worker_execute_output('eval echo ~$(whoami)'))) {
    // Clean out .ssh directory and recreate it.
    worker_directory_prepare($home . '/.ssh');

    // Initialize ssh config file.
    file_put_contents($home . '/.ssh/config', "# Auto generated by conduit. Do not modify this file manually.\n\n");

    // Cycle through ssh key information and process.
    $delta = 0;
    foreach ($properties['ssh'] as $info) {
      worker_log('Adding ssh key for host ' . $info['host'] . '.');

      // Ensure the required fields are provided.
      if (empty($info['key']) || empty($info['host']) || empty($info['user'])) {
        // @TODO Worker set_error().
      }

      // Add the default value for the port field if not specified.
      if (empty($info['port'])) {
        $info['port'] = 22;
      }

      // Write the ssh key to a file and set the appropriate permissions.
      $file = $home . '/.ssh/id_rsa.' . ++$delta;
      file_put_contents($file, $info['key']);
      chmod($file, 0600);

      // Add an entry in the ssh config file for the key.
      $config = "Host {$info['host']}\n" .
        "\tIdentityFile $file\n" .
        "\tUser {$info['user']}\n" .
        "\tPort {$info['port']}\n\n";
      file_put_contents($home . '/.ssh/config', $config, FILE_APPEND);

      // Add the host to the known_hosts file.
      worker_execute('ssh -o StrictHostKeyChecking=no ' . escapeshellarg($info['host']) . ' exit');
    }
  }
  else {
    // @TODO Worker set_error().
  }
}

/**
 * Process version control repositories.
 *
 * @param $properties
 *   Associative array of job properties.
 */
function worker_vcs(array $properties) {
  // Cycle through all repositories until complete or an error is encountered.
  foreach ($properties['vcs'] as $path => $url) {
    // Load plugin appropriate for handling scheme. Note that parse_url() does
    // not work since git urls for example are non-standard enough that it will
    // not parse them at all. Possibly just use custom format?
    list($scheme) = explode('://', $url);
    if ($vcs = worker_plugins_get('vcs', $scheme)) {
      // Ensure the path specified exists.
      worker_directory_prepare(JOB_ROOT . '/' . ltrim($path, './'));
      worker_chdir($path);

      // Checkout from the repository.
      worker_log('Checkout [' . $url . '] into [' . $path . '].');
      if (!$vcs['checkout']($url)) {
        return FALSE;
      }

      // Return to the Drupal root after processing a repository successfully
      // to ensure that the next plugin is loaded properly.
      chdir(DRUPAL_ROOT);
    }
    else {
      worker_log('Unsupported scheme in [' . $url . '].');
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Apply a patch in the working directory.
 *
 * @param $patch
 *   Path to patch file.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_patch_apply($patch) {
  return worker_execute('patch -p0 -i ' . escapeshellarg($patch));
}

/**
 * Get a list of all files modified by a patch.
 *
 * @param
 *   Path to patch file, which must be in the unified format.
 * @return
 *   List of files modified by the patch.
 */
function worker_patch_modified_files($patch) {
  // Load the patch file and use regular expression to find all files modified
  // by the patch.
  $contents = file_get_contents($patch);
  preg_match_all('/^[\+-]{3} (.*?)\s/m', $contents, $matches, PREG_SET_ORDER);

  $files = array();
  foreach ($matches as $match) {
    // Ignore reference to /dev/null which will occur when a file is being
    // added or removed.
    if ($match[1] != '/dev/null') {
      $files[$match[1]] = $match[1];
    }
  }
  return array_values($files);
}

/**
 * Wrapper for PHP exec() function.
 *
 * All commands executed on the worker should be run through this command or
 * worker_execute_output(). If the exit status is non-zero the occurance will
 * be logged.
 *
 * @param $command
 *   Command to execute.
 * @param $return_output
 *   (Optional) Return the output of the command instead of TRUE or FALSE.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 */
function worker_execute($command, $return_output = FALSE, $capture_stderr = TRUE) {
  // Redirect the stderr to stdout so it is also captured.
  if ($capture_stderr) {
    $command .= ' 2>&1';
  }

  // Execute the command and capture the output and status.
  exec($command, $output, $status);

  // If that exit status is non-zero then log the occurance.
  if ($status != 0) {
    worker_log("The following command generated a non-zero exit status of $status:\n" .
      "$command\n" .
      ($output ? trim(implode("\n", $output)) : '<<no output>>'));
    return FALSE;
  }
  return $return_output ? $output : TRUE;
}

/**
 * Wrapper for PHP exec() function that return the output.
 *
 * @param $command
 *   Command to execute.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 * @see worker_execute()
 */
function worker_execute_output($command, $capture_stderr = TRUE) {
  return worker_execute($command, TRUE, $capture_stderr);
}

/**
 * Wrapper for PHP chdir() function, that starts from JOB_ROOT.
 *
 * @param $directory
 *   Directory within the job root to switch to.
 */
function worker_chdir($directory = '') {
  $directory = ltrim($directory, './');
  chdir(JOB_ROOT . '/' . $directory);
}

/**
 * Delete a path recursively.
 *
 * Replacement for file_unmanaged_delete_recursive() since the latter will not
 * always delete symbolic links which may be contained in a directory.
 *
 * @param $path
 *   Path to directory or file that will be recursively deleted.
 */
function worker_delete_recursive($path) {
  if (is_dir($path)) {
    // Cycle through all entries in directory and recursively remove them.
    $files = scandir($path);
    foreach ($files as $file) {
      if ($file != '.' && $file != '..') {
        worker_delete_recursive($path . '/' . $file);
      }
    }

    // Remove the directory itself.
    rmdir($path);
  }
  else {
    // Do not check if the file exists since the check may fail if the file is
    // a symbolic link and the file should always exist.
    unlink($path);
  }
}

/**
 * Add the string to the log.
 *
 * @param $string
 *   Message string to log.
 */
function worker_log($string) {
  static $start, $log_file;

  // First time function is called then initialze the $start to the current
  // float version of microtime(), generate the $log_file uri and create a
  // blank log file.
  if (!$start) {
    $start = microtime(TRUE);
    $log_file = DRUPAL_ROOT . '/' . file_directory_path() . '/job.log';
    file_put_contents($log_file, '');
  }

  // Write the log message with length of time since logging was started and
  // the message followed by a newline character.
  file_put_contents($log_file, sprintf("[%10s] %s\n", number_format(microtime(TRUE) - $start, 6), $string), FILE_APPEND);
}
