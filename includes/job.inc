<?php
/**
 * @file
 * Provide convenience functions and environment setup for jobs.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * Root directory for job.
 */
define('JOB_ROOT', DRUPAL_ROOT . '/' . file_directory_path() . '/job');

/**
 * Perform the given job.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   The result of the job or FALSE.
 */
function worker_perform(array $properties) {
  $result = array(
    'status' => 'failure',
    'result' => NULL,
    'error' => NULL,
  );

  // Ensure that the job plugin can be loaded.
  if ($plugin = worker_plugins_get('worker', $properties['plugin'])) {
    worker_log('Starting job ' . $properties['item']->data['nid'] . '.' . $properties['item']->data['vid'] . '.' . $properties['item']->data['delta'] . '.');
    worker_verbose($properties['verbose']);

    // Perform preparation and then job.
    if (worker_prepare($properties)) {
      // Ensure the working directory is set to the DRUPAL_ROOT and invoke the
      // plugin with the job properties.
      chdir(DRUPAL_ROOT);
      if ($result['result'] = $plugin['perform']($properties)) {
        $result['status'] = 'success';
      }
    }

    chdir(DRUPAL_ROOT);
    worker_log('Job exiting.');
  }

  // Load log file contents as an array so the second to last line can be
  // accessed if necessary.
  $log = file(file_directory_path() . '/job.log');
  $result['log'] = implode("\n", $log);

  // If the job was a failure then use the second to last line from the log as
  // the error message after trimming off the time offset.
  if ($result['status'] == 'failure') {
    array_pop($log);
    $result['error'] = substr(array_pop($log), 12);
  }
  return $result;
}

/**
 * Perform preparation needed before job runs.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_prepare(array $properties) {
  // Ensure the job root directory is available.
  if (!worker_directory_prepare()) {
    worker_log('Failed to prepare job root directory.');
    return FALSE;
  }

  if (!worker_setup($properties)) {
    worker_log('Failed to complete execution of setup commands.');
  }

  if (!worker_ssh($properties)) {
    return FALSE;
  }

  if (!worker_vcs($properties)) {
    return FALSE;
  }

  if (!worker_patch($properties)) {
    return FALSE;
  }

  return TRUE;
}

/**
 * Prepare the job root directory.
 *
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_directory_prepare($directory = JOB_ROOT) {
  // If directory exists then clear it out.
  if (file_exists($directory)) {
    worker_delete_recursive($directory);
  }

  // Create directory.
  return file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
}

/**
 * Allow commands to be run during setup phase.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_setup(array $properties) {
  foreach ($properties['setup'] as $command) {
    worker_log('Setup [' . $command . '].');
    if (!worker_execute(escapeshellcmd($command))) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Prepare ssh keys.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_ssh(array $properties) {
  // Determine the web user home directory.
  if (($home = array_pop(worker_execute_output('eval echo ~$(whoami)'))) && is_dir($home)) {
    // Clean out .ssh directory and recreate it.
    worker_directory_prepare($home . '/.ssh');

    // Initialize ssh config file.
    file_put_contents($home . '/.ssh/config', "# Auto generated by conduit. Do not modify this file manually.\n\n");

    // Cycle through ssh key information and process.
    $delta = 0;
    foreach ($properties['ssh'] as $info) {
      worker_log('Adding ssh key for host ' . $info['host'] . '.');
      // Write the ssh key to a file and set the appropriate permissions.
      $file = $home . '/.ssh/id_rsa.' . ++$delta;
      file_put_contents($file, $info['key']);
      chmod($file, 0600);

      // Add an entry in the ssh config file for the key.
      $config = "Host {$info['host']}\n" .
        "\tIdentityFile $file\n" .
        "\tUser {$info['user']}\n" .
        "\tPort {$info['port']}\n\n";
      file_put_contents($home . '/.ssh/config', $config, FILE_APPEND);

      // Add the host to the known_hosts file.
      $line = array_shift(worker_execute_output('ssh -o StrictHostKeyChecking=no ' . escapeshellarg($info['host']) . ' exit'));
      if (preg_match('/Warning: Permanently added .*? to the list of known hosts./', $line)) {
        // Coninue with next ssh key.
        continue;
      }
      worker_log('Failed to setup ssh key for ' . $info['host'] . '.');
      return FALSE;
    }
    return TRUE;
  }
  worker_log('Failed to determine the webuser home directory path.');
  return FALSE;
}

/**
 * Process version control repositories.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_vcs(array $properties) {
  // Cycle through all repositories until complete or an error is encountered.
  foreach ($properties['vcs'] as $path => $url) {
    // Load plugin appropriate for handling the scheme.
    if ($vcs = worker_plugins_get_vcs($url)) {
      // Ensure the path specified exists.
      worker_directory_prepare(JOB_ROOT . '/' . $path);
      worker_chdir($path);

      // Checkout from the repository.
      worker_log('Checkout ' . $url . ' into /' . $path . '.');
      if (!$vcs['checkout']($url)) {
        return FALSE;
      }

      // Return to the Drupal root after processing a repository successfully
      // to ensure that the next plugin is loaded properly.
      chdir(DRUPAL_ROOT);
    }
    else {
      worker_log('Unsupported scheme in [' . $url . '].');
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Apply a list of patches.
 *
 * @param $properties
 *   Associative array of job properties.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_patch(array $properties) {
  // Prepare patch storage directory.
  worker_directory_prepare($directory = DRUPAL_ROOT . '/' . file_directory_path() . '/patch');

  // Cycle through all the patches, download them and apply them.
  $delta = 0;
  foreach ($properties['patch'] as $url => $path) {
    if (!empty($properties['vcs'][$path]) && ($vcs = worker_plugins_get_vcs($properties['vcs'][$path]))) {
      // Use the path specified as the root the patch is to be applied to. Use
      // a delta to ensure patch file names do not conflict.
      worker_chdir($path);
      $local = worker_fetch($url, $directory, $delta++);
      $name = basename($url);

      // Ensure that path the patch is to be applied to is readable.
      worker_log('Apply ' . $name . ' to /' . $path . '.');
      if (!$vcs['apply']($local)) {
        worker_log('Failed to apply patch ' . $name . '.');
        return FALSE;
      }
      worker_log("Modified files:\n > " . implode("\n > ", $vcs['modified files']($local)));
    }
    else {
      worker_log('No repository corresponds to path /' . $path . ' for ' . basename($url) . '.');
      return FALSE;
    }
  }
  chdir(DRUPAL_ROOT);
  return TRUE;
}

/**
 * Fetch a file and place in directory.
 *
 * @param $url
 *   URL of file to fetch.
 * @param $directory
 *   Directory to place file in.
 * @param $suffix
 *   Suffix to append to the local name of the file.
 * @return
 *   Local path to file, or FALSE if retrieval/storage failed.
 */
function worker_fetch($url, $directory, $suffix = '') {
  // Request the file at the given URL.
  $response = drupal_http_request($url); // @TODO Possibly allow for none http protocols.
  if ($response->code != 200) {
    worker_log('Unable to fetch ' . $url . ' due to [' . $response->error . '].');
    return FALSE;
  }

  // Save the file contents in the given directory.
  $local = $directory . '/' . basename($url) . $suffix;
  if (file_put_contents($local, $response->data) === FALSE) {
    worker_log('Failed to save file data to ' . $local . '.');
    return FALSE;
  }
  return $local;
}

/**
 * Apply a patch in the working directory.
 *
 * @param $patch
 *   Path to patch file.
 * @return
 *   TRUE if successfull, otherwise FALSE.
 */
function worker_patch_apply($patch) {
  return worker_execute('patch -p0 -i ' . escapeshellarg($patch));
}

/**
 * Get a list of all files modified by a patch.
 *
 * @param
 *   Path to patch file, which must be in the unified format.
 * @return
 *   List of files modified by the patch.
 */
function worker_patch_modified_files($patch) {
  // Load the patch file and use regular expression to find all files modified
  // by the patch.
  $contents = file_get_contents($patch);
  preg_match_all('/^[\+-]{3} (.*?)\s/m', $contents, $matches, PREG_SET_ORDER);

  $files = array();
  foreach ($matches as $match) {
    // Ignore reference to /dev/null which will occur when a file is being
    // added or removed.
    if ($match[1] != '/dev/null') {
      $files[$match[1]] = $match[1];
    }
  }
  return array_values($files);
}

/**
 * Wrapper for PHP exec() function.
 *
 * All commands executed on the worker should be run through this command or
 * worker_execute_output(). If the exit status is non-zero the occurance will
 * be logged.
 *
 * @param $command
 *   Command to execute.
 * @param $return_output
 *   (Optional) Return the output of the command instead of TRUE or FALSE.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 */
function worker_execute($command, $return_output = FALSE, $capture_stderr = TRUE) {
  // Redirect the stderr to stdout so it is also captured.
  if ($capture_stderr) {
    $command .= ' 2>&1';
  }

  // Execute the command and capture the output and status.
  exec($command, $output, $status);

  // If that exit status is non-zero then log the occurance.
  if ($status != 0 || worker_verbose()) {
    worker_log("The following command generated a non-zero exit status of $status:\n" .
      "$command\n" .
      ($output ? trim(implode("\n", $output)) : '<<no output>>'));
  }
  return $return_output ? $output : $status == 0;
}

/**
 * Wrapper for PHP exec() function that return the output.
 *
 * @param $command
 *   Command to execute.
 * @param $capture_stderr
 *   Capture the stderr as part of the output.
 * @return
 *   If successfull then TRUE or the output of the command, otherwise FALSE.
 * @see worker_execute()
 */
function worker_execute_output($command, $capture_stderr = TRUE) {
  return worker_execute($command, TRUE, $capture_stderr);
}

/**
 * Wrapper for PHP chdir() function, that starts from JOB_ROOT.
 *
 * @param $directory
 *   Directory within the job root to switch to.
 */
function worker_chdir($directory = '') {
  chdir(JOB_ROOT . '/' . $directory);
}

/**
 * Delete a path recursively.
 *
 * Replacement for file_unmanaged_delete_recursive() since the latter will not
 * always delete symbolic links which may be contained in a directory.
 *
 * @param $path
 *   Path to directory or file that will be recursively deleted.
 */
function worker_delete_recursive($path) {
  if (is_dir($path)) {
    // Cycle through all entries in directory and recursively remove them.
    $files = scandir($path);
    foreach ($files as $file) {
      if ($file != '.' && $file != '..') {
        worker_delete_recursive($path . '/' . $file);
      }
    }

    // Remove the directory itself.
    rmdir($path);
  }
  else {
    // Do not check if the file exists since the check may fail if the file is
    // a symbolic link and the file should always exist.
    unlink($path);
  }
}

/**
 * Add the string to the log.
 *
 * @param $string
 *   Message string to log.
 */
function worker_log($string) {
  static $start, $log_file;

  // First time function is called then initialze the $start to the current
  // float version of microtime(), generate the $log_file uri and create a
  // blank log file.
  if (!$start) {
    $start = microtime(TRUE);
    $log_file = DRUPAL_ROOT . '/' . file_directory_path() . '/job.log';
    file_put_contents($log_file, '');
  }

  // Write the log message with length of time since logging was started and
  // the message followed by a newline character.
  file_put_contents($log_file, sprintf("[%10s] %s\n", number_format(microtime(TRUE) - $start, 6), $string), FILE_APPEND);
}

/**
 * Check if worker is in verbose mode.
 *
 * @param
 *   (Optional) Verbose mode to use, this should only be set by worker init.
 * @return
 *   TRUE if in verbose mode, otherwise FALSE.
 */
function worker_verbose($verbose = NULL) {
  static $_verbose;
  if ($verbose) {
    $_verbose = (bool) $verbose;
  }
  return $_verbose;
}
